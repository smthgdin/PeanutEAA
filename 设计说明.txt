
DDD+面向接口+参考ABP

软件中一般有三种服务：应用层服务、领域服务、基础服务。

不遵循DDD或ABP设计的地方：
1.UoW放到基础设施层而不放在领域层，个人觉得UoW更多是事务的封装贴近数据库和ORM的关系密切，ORM位于基础设施层，所以UoW也放一起。
2.领域层的服务移到应用层，为了简化代码不想多个层分散各自的服务，按照应用层定义应用层虽然不包含逻辑但是可以包含调用过程，领域层的服务也类似，所以放在一起暂时也可以，而且代码好懂、调试也不用跳来跳去。
3.

关注点分离
领域模型包含：领域数据和领域逻辑。
领域模型的CRUD都放到仓储中，仓储其实就是模型的仓库。
UoW负责事务管理，以及持久化。 这样领域模型就只需要关注自己的业务逻辑就行了。
至于数据库连接管理有ORM去实现，UoW对事物的管理其实也是封装ORM的事务管理。分布式事务怎么办？

需求调研时，既有业务的整体的了解，也有零零碎碎断断续续的小业务片段的了解，所以有时候同时采用自顶向下或自下向上的分析都可能。
拆分成许多领域模型和值模型之后，就可以分析出哪些领域模型和值对象可以聚合成一个聚合。
目前，暂不考虑聚合，因为觉得让程序更复杂，对于领域的访问更别扭（按照DDD对于聚合内实体和值的访问都要经过聚合）；


领域模型T,数据表模型V。
领域模型是业务相关的，数据模型是表相关的和数据库表映射的。

领域模型获得过程：提取名词-->识别名词信息-->识别名词关系-->UML图
领域模型-->设计模型（领域模型基础上：1.设计属性、方法；2.设计管理器（仓储）；3.运用设计原则和模式。）
实现模型就是具体编码。

命令查询分离（CQS）两原则：查询永远不应该改变状态；命令可以改变状态但不应该有返回值。
把CRUD从仓储移到UoW？仓储只有读取操作。当然，对模型依然没影响，因为模型和数据库连接管理、数据库操作以及事务已经分离。
        

ctx.Database.ExecuteSqlCommand();
ctx.SqlQuery<PersonView>("SELECT PersonID, Name FROM Person").ToList();

Repository：是一个独立的层，介于领域层与数据映射层（数据访问层）之间。分离业务和持久化。
Repository是仓库管理员，领域层需要什么东西只需告诉仓库管理员，由仓库管理员把东西拿给它，并不需要知道东西实际放在哪。

在EF 6.0版本以上，EF一直保持数据库连接打开，因为要启动一个transaction必须是在数据库连接打开的前提下，
同时这也就意味着我们执行多个操作在一个transaction的唯一方式是要么使用 TransactionScope 
要么使用  ObjectContext.Connection 属性并且启动调用Open()方法以及BeginTransaction()方法直接返回EntityConnection对象。
如果你在底层数据库连接上启动了transaction，再调用API连接数据库可能会失败。 


服务是行为的抽象。
应用服务通过委托领域对象和领域服务来表达用例和用户故事。
领域对象（实体和值对象）负责单一操作。
领域服务用于协调多个领域对象共同完成某个业务操作。
应用服务不处理业务逻辑，领域服务处理业务逻辑。

各类第三方框架的注入可以考虑使用MEF。对象级别的注入可以使用IOC容器。
